<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced AI Multi-Model System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --dark: #0a0a0a;
            --dark-light: #1a1a1a;
            --dark-lighter: #2a2a2a;
            --text: #e0e0e0;
            --text-dim: #999;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--dark);
            color: var(--text);
            line-height: 1.6;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 40px 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }
        
        .header h1 {
            font-size: 42px;
            margin-bottom: 10px;
            font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 18px;
            opacity: 0.95;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 30px 20px;
        }
        
        /* Control Panel */
        .control-panel {
            background: var(--dark-light);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: var(--dark-lighter);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 10px;
            color: var(--primary);
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group input,
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 12px;
            background: var(--dark);
            border: 2px solid #333;
            border-radius: 8px;
            color: var(--text);
            font-size: 15px;
            transition: all 0.3s;
        }
        
        .control-group input:focus,
        .control-group select:focus,
        .control-group textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .control-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        /* Buttons */
        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: var(--dark-lighter);
            color: var(--text);
            border: 2px solid #444;
        }
        
        .btn-secondary:hover {
            background: #333;
            border-color: var(--primary);
        }
        
        /* Dashboard */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        /* Model Cards Container */
        .models-container {
            background: var(--dark-light);
            border-radius: 20px;
            padding: 25px;
            min-height: 600px;
        }
        
        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .model-card {
            background: var(--dark-lighter);
            border-radius: 16px;
            padding: 20px;
            border: 2px solid #333;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .model-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
            transition: background 0.3s;
        }
        
        .model-card.processing::before {
            background: linear-gradient(90deg, var(--warning), var(--primary), var(--warning));
            background-size: 200% 100%;
            animation: loading 2s linear infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .model-card.completed::before {
            background: var(--success);
        }
        
        .model-card.error::before {
            background: var(--error);
        }
        
        .model-card.streaming-mode {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.2);
        }
        
        .model-content.typing::after {
            content: '|';
            animation: blink 1s infinite;
            color: var(--primary);
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .model-name {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
        }
        
        .model-badge {
            display: flex;
            gap: 8px;
        }
        
        .badge {
            padding: 4px 10px;
            background: var(--primary);
            color: white;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .model-status {
            margin-bottom: 15px;
            padding: 8px 12px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
        }
        
        .status-waiting { background: #333; color: var(--text-dim); }
        .status-processing { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .status-completed { background: rgba(34, 197, 94, 0.2); color: var(--success); }
        .status-error { background: rgba(239, 68, 68, 0.2); color: var(--error); }
        
        .model-content {
            background: var(--dark);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.8;
            white-space: pre-wrap;
            border: 1px solid #333;
        }
        
        /* Quality Metrics */
        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .metric-item {
            background: var(--dark);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #333;
        }
        
        .metric-label {
            font-size: 11px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
        }
        
        .metric-score {
            font-size: 24px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Sidebar Stats */
        .sidebar {
            background: var(--dark-light);
            border-radius: 20px;
            padding: 25px;
            position: sticky;
            top: 20px;
            height: fit-content;
        }
        
        .stat-card {
            background: var(--dark-lighter);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid #333;
        }
        
        .stat-value {
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .stat-label {
            font-size: 13px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-top: 5px;
        }
        
        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--dark);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 10px;
            transition: width 0.3s;
        }
        
        /* Leaderboard */
        .leaderboard {
            background: var(--dark-lighter);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
        }
        
        .leaderboard h3 {
            margin-bottom: 15px;
            color: var(--primary);
            font-size: 16px;
            text-transform: uppercase;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--dark);
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #333;
            transition: all 0.3s;
        }
        
        .leaderboard-item:hover {
            transform: translateX(5px);
            border-color: var(--primary);
        }
        
        .leaderboard-rank {
            width: 30px;
            height: 30px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
        }
        
        .leaderboard-item.gold .leaderboard-rank { background: #ffd700; color: #000; }
        .leaderboard-item.silver .leaderboard-rank { background: #c0c0c0; color: #000; }
        .leaderboard-item.bronze .leaderboard-rank { background: #cd7f32; color: #fff; }
        
        .leaderboard-model {
            flex: 1;
            margin: 0 15px;
            font-weight: 600;
        }
        
        .leaderboard-score {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
        }
        
        /* Final Result */
        .final-result {
            background: var(--dark-light);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            display: none;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.2);
            border: 2px solid var(--primary);
        }
        
        .final-result.show {
            display: block;
        }
        
        .winner-badge {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: 700;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-left-color: var(--primary);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--dark);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><i class="fas fa-brain"></i> Advanced AI Multi-Model System</h1>
        <p>6개의 최강 AI 모델과 자동 품질 평가 시스템</p>
    </div>
    
    <div class="container">
        <!-- Control Panel -->
        <div class="control-panel">
            <h2 style="margin-bottom: 25px; color: var(--primary);">
                <i class="fas fa-cogs"></i> 콘텐츠 생성 설정
            </h2>
            
            <div class="control-grid">
                <div class="control-group">
                    <label><i class="fas fa-heading"></i> 주제</label>
                    <input type="text" id="topic" placeholder="예: AI가 바꾸는 미래의 교육" value="AI가 바꾸는 미래의 교육">
                </div>
                
                <div class="control-group">
                    <label><i class="fas fa-list"></i> 콘텐츠 타입</label>
                    <select id="contentType">
                        <option value="blog">블로그 포스트</option>
                        <option value="article">기사</option>
                        <option value="tutorial">튜토리얼</option>
                        <option value="review">리뷰</option>
                        <option value="story">스토리</option>
                        <option value="analysis">분석</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label><i class="fas fa-ruler"></i> 길이</label>
                    <select id="contentLength">
                        <option value="200">짧게 (200자)</option>
                        <option value="500" selected>보통 (500자)</option>
                        <option value="1000">길게 (1000자)</option>
                        <option value="1500">매우 길게 (1500자)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label><i class="fas fa-palette"></i> 톤 & 스타일</label>
                    <select id="tone">
                        <option value="professional">전문적</option>
                        <option value="casual">캐주얼</option>
                        <option value="academic">학술적</option>
                        <option value="creative">창의적</option>
                        <option value="persuasive">설득적</option>
                    </select>
                </div>
                
                <div class="control-group" style="grid-column: span 2;">
                    <label><i class="fas fa-comment-dots"></i> 추가 지시사항</label>
                    <textarea id="additionalPrompt" placeholder="특별한 요구사항이나 스타일 지시사항을 입력하세요..."></textarea>
                </div>
            </div>
            
            <div class="button-group">
                <button class="btn btn-primary" onclick="generateAll()">
                    <i class="fas fa-rocket"></i> 6개 모델 동시 생성
                </button>
                <button class="btn btn-secondary" onclick="evaluateQuality()">
                    <i class="fas fa-chart-bar"></i> 품질 평가 실행
                </button>
                <button class="btn btn-secondary" onclick="streamGenerate()">
                    <i class="fas fa-stream"></i> 스트리밍 모드
                </button>
                <button class="btn btn-secondary" onclick="saveAllResults()">
                    <i class="fas fa-save"></i> 결과 저장
                </button>
                <button class="btn btn-secondary" onclick="exportReport()">
                    <i class="fas fa-file-export"></i> 리포트 내보내기
                </button>
            </div>
        </div>
        
        <!-- Dashboard -->
        <div class="dashboard">
            <!-- Models Container -->
            <div class="models-container">
                <div class="models-grid" id="modelsGrid">
                    <!-- Model cards will be dynamically generated here -->
                </div>
            </div>
            
            <!-- Sidebar Stats -->
            <div class="sidebar">
                <div class="stat-card">
                    <div class="stat-value" id="activeCount">0</div>
                    <div class="stat-label">실행 중</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-value" id="completedCount">0</div>
                    <div class="stat-label">완료</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-value" id="avgScore">0</div>
                    <div class="stat-label">평균 점수</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-value" id="bestTime">0</div>
                    <div class="stat-label">최고 속도 (ms)</div>
                </div>
                
                <!-- Progress -->
                <div style="margin: 20px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="font-size: 12px; color: var(--text-dim);">진행률</span>
                        <span style="font-size: 12px; color: var(--primary);" id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                    </div>
                </div>
                
                <!-- Leaderboard -->
                <div class="leaderboard">
                    <h3><i class="fas fa-trophy"></i> 실시간 순위</h3>
                    <div id="leaderboard">
                        <!-- Leaderboard items will be dynamically generated -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Final Result -->
        <div class="final-result" id="finalResult">
            <div class="winner-badge">
                <i class="fas fa-crown"></i>
                <span id="winnerName">최고 모델</span>
            </div>
            
            <div class="model-content" id="winnerContent">
                <!-- Winning content will be displayed here -->
            </div>
            
            <div class="quality-metrics" id="winnerMetrics">
                <!-- Winner metrics will be displayed here -->
            </div>
            
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn btn-primary" onclick="publishWinner()">
                    <i class="fas fa-upload"></i> 발행
                </button>
                <button class="btn btn-secondary" onclick="regenerate()">
                    <i class="fas fa-redo"></i> 재생성
                </button>
                <button class="btn btn-secondary" onclick="compareAll()">
                    <i class="fas fa-compress"></i> 상세 비교
                </button>
            </div>
        </div>
    </div>
    
    <!-- Ollama Cloud API 추가 -->
    <script src="../js/ollama-cloud-api.js"></script>
    
    <script>
        // Model configurations - Ollama Cloud 통합
        const models = {
            'llama3': {
                id: 'llama3.2',
                name: 'Llama 3.2 Latest',
                type: 'ollama-cloud',
                params: '8B',
                apiKey: '3c59fcbdf15b4c02b64e93a544add018.4gypXlrDEbnV4gtneL7jCoB4'
            },
            'qwen25': {
                id: 'qwen2.5',
                name: 'Qwen 2.5 Coder',
                type: 'ollama-cloud',
                params: '7B',
                apiKey: '3c59fcbdf15b4c02b64e93a544add018.4gypXlrDEbnV4gtneL7jCoB4'
            },
            'gemma2': {
                id: 'gemma2',
                name: 'Google Gemma 2',
                type: 'ollama-cloud',
                params: '9B',
                apiKey: '3c59fcbdf15b4c02b64e93a544add018.4gypXlrDEbnV4gtneL7jCoB4'
            },
            'mistral': {
                id: 'mistral',
                name: 'Mistral Latest',
                type: 'ollama-cloud',
                params: '7B',
                apiKey: '3c59fcbdf15b4c02b64e93a544add018.4gypXlrDEbnV4gtneL7jCoB4'
            },
            'gemini-flash': {
                id: 'gemini-2.0-flash-exp',
                name: 'Gemini 2.0 Flash',
                type: 'gemini',
                apiKey: 'AIzaSyAmLSwyMGCkDpSojwPjQwTnYmlAQjrdH7g',
                params: 'Flash 2.0'
            },
            'gemini-pro': {
                id: 'gemini-2.0-flash',
                name: 'Gemini Flash Pro',
                type: 'gemini',
                apiKey: 'AIzaSyAmLSwyMGCkDpSojwPjQwTnYmlAQjrdH7g',
                params: 'Pro'
            }
        };
        
        let results = {};
        let qualityScores = {};
        
        // Initialize model cards
        function initializeModels() {
            const grid = document.getElementById('modelsGrid');
            grid.innerHTML = '';
            results = {};
            qualityScores = {};
            
            Object.entries(models).forEach(([key, model]) => {
                const card = document.createElement('div');
                card.className = 'model-card';
                card.id = `card-${key}`;
                
                card.innerHTML = `
                    <div class="model-header">
                        <div class="model-name">${model.name}</div>
                        <div class="model-badge">
                            <span class="badge">${model.params}</span>
                            <span class="badge" style="background: #333;">${model.type}</span>
                        </div>
                    </div>
                    <div class="model-status status-waiting">
                        <i class="fas fa-clock"></i> 대기 중
                    </div>
                    <div class="model-content" style="display: none;"></div>
                    <div class="quality-metrics" style="display: none;">
                        <div class="metric-item">
                            <div class="metric-label">속도</div>
                            <div class="metric-value">-</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">길이</div>
                            <div class="metric-value">-</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">품질</div>
                            <div class="metric-value">-</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">점수</div>
                            <div class="metric-value metric-score">-</div>
                        </div>
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }
        
        // Generate content for all models
        async function generateAll() {
            const topic = document.getElementById('topic').value;
            const contentType = document.getElementById('contentType').value;
            const contentLength = document.getElementById('contentLength').value;
            const tone = document.getElementById('tone').value;
            const additionalPrompt = document.getElementById('additionalPrompt').value;
            
            if (!topic) {
                alert('주제를 입력해주세요');
                return;
            }
            
            // Build prompt
            const prompt = `
주제: ${topic}
타입: ${contentType}
길이: 약 ${contentLength}자
톤: ${tone}
${additionalPrompt ? `추가 지시: ${additionalPrompt}` : ''}

위 조건에 맞는 ${contentType}를 ${contentLength}자 내외로 작성해주세요.
한국어로 작성하고, ${tone === 'professional' ? '전문적이면서도' : 
                     tone === 'casual' ? '친근하면서도' :
                     tone === 'academic' ? '학술적이면서도' :
                     tone === 'creative' ? '창의적이면서도' :
                     '설득력 있으면서도'} 읽기 쉽게 작성해주세요.
            `.trim();
            
            initializeModels();
            updateStats(6, 0, 0, 0);
            
            // Generate for all models in parallel
            const promises = Object.entries(models).map(([key, model]) => 
                generateForModel(key, model, prompt)
            );
            
            await Promise.allSettled(promises);
            
            // Auto evaluate quality
            setTimeout(() => evaluateQuality(), 500);
        }
        
        // Generate for individual model
        async function generateForModel(key, model, prompt) {
            const card = document.getElementById(`card-${key}`);
            const statusEl = card.querySelector('.model-status');
            const contentEl = card.querySelector('.model-content');
            const metricsEl = card.querySelector('.quality-metrics');
            
            card.classList.add('processing');
            statusEl.className = 'model-status status-processing';
            statusEl.innerHTML = '<div class="spinner"></div> 생성 중...';
            
            const startTime = Date.now();
            
            try {
                let response;
                let content;
                
                if (model.type === 'gemini') {
                    response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/${model.id}:generateContent?key=${model.apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.8,
                                    maxOutputTokens: parseInt(document.getElementById('contentLength').value) * 2,
                                    topP: 0.95
                                }
                            })
                        }
                    );
                    
                    const data = await response.json();
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    
                } else if (model.type === 'ollama-cloud') {
                    // Ollama Cloud API 사용
                    if (window.ollamaCloudAPI) {
                        window.ollamaCloudAPI.setModel(model.id);
                        content = await window.ollamaCloudAPI.generateContent(prompt, {
                            maxTokens: parseInt(document.getElementById('contentLength').value) * 2,
                            temperature: 0.8
                        });
                    } else {
                        throw new Error('Ollama Cloud API가 로드되지 않았습니다');
                    }
                } else {
                    // 로컬 Ollama (폴백)
                    response = await fetch('http://localhost:11434/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: model.id,
                            messages: [{ role: 'user', content: prompt }],
                            stream: false,
                            options: {
                                temperature: 0.8,
                                num_predict: parseInt(document.getElementById('contentLength').value) * 2
                            }
                        })
                    });
                    
                    const data = await response.json();
                    content = data.message?.content || '';
                }
                
                const duration = Date.now() - startTime;
                
                results[key] = {
                    content: content,
                    duration: duration,
                    length: content.length,
                    success: !!content
                };
                
                // Update UI
                card.classList.remove('processing');
                card.classList.add('completed');
                statusEl.className = 'model-status status-completed';
                statusEl.innerHTML = '<i class="fas fa-check"></i> 완료';
                
                contentEl.style.display = 'block';
                contentEl.textContent = content;
                
                metricsEl.style.display = 'grid';
                metricsEl.querySelectorAll('.metric-value')[0].textContent = `${duration}ms`;
                metricsEl.querySelectorAll('.metric-value')[1].textContent = `${content.length}자`;
                
                updateCompletedCount();
                
            } catch (error) {
                card.classList.remove('processing');
                card.classList.add('error');
                statusEl.className = 'model-status status-error';
                statusEl.innerHTML = '<i class="fas fa-times"></i> 오류';
                
                contentEl.style.display = 'block';
                contentEl.textContent = `오류: ${error.message}`;
                
                results[key] = { error: error.message, success: false };
                updateCompletedCount();
            }
        }
        
        // Evaluate quality
        async function evaluateQuality() {
            const successfulResults = Object.entries(results).filter(([_, r]) => r.success);
            
            if (successfulResults.length === 0) {
                alert('평가할 콘텐츠가 없습니다');
                return;
            }
            
            for (const [key, result] of successfulResults) {
                const score = calculateQualityScore(result.content, result.duration, result.length);
                qualityScores[key] = score;
                
                // Update UI
                const card = document.getElementById(`card-${key}`);
                const metricsEl = card.querySelector('.quality-metrics');
                metricsEl.querySelectorAll('.metric-value')[2].textContent = `${score.quality}%`;
                metricsEl.querySelectorAll('.metric-value')[3].textContent = score.total;
            }
            
            updateLeaderboard();
            showWinner();
        }
        
        // Calculate quality score
        function calculateQualityScore(content, duration, length) {
            let score = {
                speed: 0,
                length: 0,
                quality: 0,
                structure: 0,
                total: 0
            };
            
            // Speed score (faster is better)
            if (duration < 2000) score.speed = 100;
            else if (duration < 5000) score.speed = 80;
            else if (duration < 10000) score.speed = 60;
            else if (duration < 20000) score.speed = 40;
            else score.speed = 20;
            
            // Length score (closer to target is better)
            const targetLength = parseInt(document.getElementById('contentLength').value);
            const lengthDiff = Math.abs(length - targetLength);
            if (lengthDiff < 50) score.length = 100;
            else if (lengthDiff < 100) score.length = 80;
            else if (lengthDiff < 200) score.length = 60;
            else if (lengthDiff < 300) score.length = 40;
            else score.length = 20;
            
            // Content quality score
            score.quality = 0;
            
            // Check for Korean content
            if (/[가-힣]/.test(content)) score.quality += 20;
            
            // Check for paragraphs
            if (content.includes('\n\n') || content.includes('\n')) score.quality += 20;
            
            // Check for proper punctuation
            if (content.includes('.') && content.includes(',')) score.quality += 15;
            
            // Check for variety in sentence length
            const sentences = content.split(/[.!?]/).filter(s => s.trim());
            if (sentences.length > 3) score.quality += 15;
            
            // Check for keywords from topic
            const topic = document.getElementById('topic').value.toLowerCase();
            const topicWords = topic.split(' ');
            let keywordCount = 0;
            topicWords.forEach(word => {
                if (content.toLowerCase().includes(word)) keywordCount++;
            });
            score.quality += Math.min(30, keywordCount * 10);
            
            // Structure score
            score.structure = 0;
            if (content.length > 100) score.structure += 25;
            if (content.includes('\n')) score.structure += 25;
            if (sentences.length > 2 && sentences.length < 20) score.structure += 25;
            if (content.match(/^\s*[#\-\*\d]/m)) score.structure += 25; // Lists or headers
            
            // Calculate total score
            score.total = Math.round(
                (score.speed * 0.2 + 
                 score.length * 0.2 + 
                 score.quality * 0.4 + 
                 score.structure * 0.2)
            );
            
            return score;
        }
        
        // Update statistics
        function updateStats(total, completed, avgScore, bestTime) {
            document.getElementById('activeCount').textContent = total - completed;
            document.getElementById('completedCount').textContent = completed;
            document.getElementById('avgScore').textContent = avgScore;
            document.getElementById('bestTime').textContent = bestTime;
            
            const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
            document.getElementById('progressPercent').textContent = `${progress}%`;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }
        
        // Update completed count
        function updateCompletedCount() {
            const total = Object.keys(models).length;
            const completed = Object.values(results).filter(r => r.success !== undefined).length;
            
            const scores = Object.values(qualityScores);
            const avgScore = scores.length > 0 
                ? Math.round(scores.reduce((a, b) => a + b.total, 0) / scores.length)
                : 0;
            
            const times = Object.values(results)
                .filter(r => r.success && r.duration)
                .map(r => r.duration);
            const bestTime = times.length > 0 ? Math.min(...times) : 0;
            
            updateStats(total, completed, avgScore, bestTime);
        }
        
        // Update leaderboard
        function updateLeaderboard() {
            const leaderboard = document.getElementById('leaderboard');
            leaderboard.innerHTML = '';
            
            const rankedModels = Object.entries(qualityScores)
                .sort((a, b) => b[1].total - a[1].total)
                .slice(0, 6);
            
            rankedModels.forEach(([key, score], index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                if (index === 0) item.classList.add('gold');
                else if (index === 1) item.classList.add('silver');
                else if (index === 2) item.classList.add('bronze');
                
                item.innerHTML = `
                    <div class="leaderboard-rank">${index + 1}</div>
                    <div class="leaderboard-model">${models[key].name}</div>
                    <div class="leaderboard-score">${score.total}</div>
                `;
                
                leaderboard.appendChild(item);
            });
        }
        
        // Show winner
        function showWinner() {
            const winner = Object.entries(qualityScores)
                .sort((a, b) => b[1].total - a[1].total)[0];
            
            if (!winner) return;
            
            const [key, score] = winner;
            const result = results[key];
            
            const finalResult = document.getElementById('finalResult');
            finalResult.classList.add('show');
            
            document.getElementById('winnerName').textContent = `🏆 ${models[key].name} - 최고 점수: ${score.total}`;
            document.getElementById('winnerContent').textContent = result.content;
            
            const metricsHtml = `
                <div class="metric-item">
                    <div class="metric-label">속도 점수</div>
                    <div class="metric-value">${score.speed}</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">길이 점수</div>
                    <div class="metric-value">${score.length}</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">품질 점수</div>
                    <div class="metric-value">${score.quality}</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">구조 점수</div>
                    <div class="metric-value">${score.structure}</div>
                </div>
            `;
            document.getElementById('winnerMetrics').innerHTML = metricsHtml;
            
            // Scroll to result
            finalResult.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // Stream generate - Real-time streaming
        async function streamGenerate() {
            const topic = document.getElementById('topic').value;
            const contentType = document.getElementById('contentType').value;
            const contentLength = document.getElementById('contentLength').value;
            const tone = document.getElementById('tone').value;
            const additionalPrompt = document.getElementById('additionalPrompt').value;
            
            if (!topic) {
                alert('주제를 입력해주세요');
                return;
            }
            
            // Build prompt
            const prompt = `
주제: ${topic}
타입: ${contentType}
길이: 약 ${contentLength}자
톤: ${tone}
${additionalPrompt ? `추가 지시: ${additionalPrompt}` : ''}

위 조건에 맞는 ${contentType}를 ${contentLength}자 내외로 작성해주세요.
한국어로 작성하고, ${tone === 'professional' ? '전문적이면서도' : 
                     tone === 'casual' ? '친근하면서도' :
                     tone === 'academic' ? '학술적이면서도' :
                     tone === 'creative' ? '창의적이면서도' :
                     '설득력 있으면서도'} 읽기 쉽게 작성해주세요.
            `.trim();
            
            initializeModels();
            updateStats(6, 0, 0, 0);
            
            // Enable streaming mode visual indicators
            document.querySelectorAll('.model-card').forEach(card => {
                card.classList.add('streaming-mode');
            });
            
            // Stream for all models in parallel
            const promises = Object.entries(models).map(([key, model]) => 
                streamForModel(key, model, prompt)
            );
            
            await Promise.allSettled(promises);
            
            // Auto evaluate quality after streaming
            setTimeout(() => evaluateQuality(), 1000);
        }
        
        // Stream for individual model
        async function streamForModel(key, model, prompt) {
            const card = document.getElementById(`card-${key}`);
            const statusEl = card.querySelector('.model-status');
            const contentEl = card.querySelector('.model-content');
            const metricsEl = card.querySelector('.quality-metrics');
            
            card.classList.add('processing');
            statusEl.className = 'model-status status-processing';
            statusEl.innerHTML = '<div class="spinner"></div> 스트리밍 중...';
            
            contentEl.style.display = 'block';
            contentEl.textContent = '';
            
            const startTime = Date.now();
            let fullContent = '';
            let chunks = [];
            
            try {
                if (model.type === 'gemini') {
                    // Gemini doesn't support streaming in this implementation
                    // So we'll simulate streaming by making a regular request and displaying it progressively
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/${model.id}:generateContent?key=${model.apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.8,
                                    maxOutputTokens: parseInt(document.getElementById('contentLength').value) * 2,
                                    topP: 0.95
                                }
                            })
                        }
                    );
                    
                    const data = await response.json();
                    fullContent = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    
                    // Simulate streaming by displaying content progressively
                    await simulateStreamingDisplay(contentEl, fullContent);
                    
                } else {
                    // Ollama with real streaming
                    const response = await fetch('http://localhost:11434/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: model.id,
                            messages: [{ role: 'user', content: prompt }],
                            stream: true,
                            options: {
                                temperature: 0.8,
                                num_predict: parseInt(document.getElementById('contentLength').value) * 2
                            }
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n').filter(line => line.trim());
                        
                        for (const line of lines) {
                            try {
                                const data = JSON.parse(line);
                                if (data.message?.content) {
                                    fullContent += data.message.content;
                                    chunks.push(data.message.content);
                                    
                                    // Real-time update
                                    contentEl.textContent = fullContent;
                                    contentEl.scrollTop = contentEl.scrollHeight;
                                    
                                    // Add typing animation
                                    contentEl.classList.add('typing');
                                    setTimeout(() => contentEl.classList.remove('typing'), 100);
                                }
                                
                                if (data.done) break;
                            } catch (e) {
                                // Skip malformed JSON lines
                                continue;
                            }
                        }
                    }
                }
                
                const duration = Date.now() - startTime;
                
                results[key] = {
                    content: fullContent,
                    duration: duration,
                    length: fullContent.length,
                    success: !!fullContent,
                    chunks: chunks.length,
                    streamingMode: true
                };
                
                // Update UI
                card.classList.remove('processing');
                card.classList.add('completed');
                statusEl.className = 'model-status status-completed';
                statusEl.innerHTML = '<i class="fas fa-check"></i> 스트리밍 완료';
                
                metricsEl.style.display = 'grid';
                metricsEl.querySelectorAll('.metric-value')[0].textContent = `${duration}ms`;
                metricsEl.querySelectorAll('.metric-value')[1].textContent = `${fullContent.length}자`;
                
                updateCompletedCount();
                
            } catch (error) {
                card.classList.remove('processing');
                card.classList.add('error');
                statusEl.className = 'model-status status-error';
                statusEl.innerHTML = '<i class="fas fa-times"></i> 스트리밍 오류';
                
                contentEl.textContent = `스트리밍 오류: ${error.message}`;
                
                results[key] = { error: error.message, success: false };
                updateCompletedCount();
            }
        }
        
        // Simulate streaming display for non-streaming APIs
        async function simulateStreamingDisplay(element, content) {
            element.textContent = '';
            const words = content.split(' ');
            
            for (let i = 0; i < words.length; i++) {
                element.textContent = words.slice(0, i + 1).join(' ');
                element.scrollTop = element.scrollHeight;
                
                // Add typing animation
                element.classList.add('typing');
                setTimeout(() => element.classList.remove('typing'), 50);
                
                // Variable delay for more natural typing
                const delay = Math.random() * 50 + 20;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        // Save results
        function saveAllResults() {
            const data = {
                timestamp: new Date().toISOString(),
                topic: document.getElementById('topic').value,
                results: results,
                scores: qualityScores,
                settings: {
                    contentType: document.getElementById('contentType').value,
                    contentLength: document.getElementById('contentLength').value,
                    tone: document.getElementById('tone').value
                }
            };
            
            localStorage.setItem('advancedModelResults', JSON.stringify(data));
            
            // Create downloadable JSON
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-results-${Date.now()}.json`;
            a.click();
            
            alert('결과가 저장되었습니다!');
        }
        
        // Export report
        function exportReport() {
            let report = '# AI Multi-Model Generation Report\n\n';
            report += `**Date:** ${new Date().toLocaleString()}\n\n`;
            report += `**Topic:** ${document.getElementById('topic').value}\n\n`;
            report += '## Results\n\n';
            
            Object.entries(results).forEach(([key, result]) => {
                if (result.success) {
                    const score = qualityScores[key] || {};
                    report += `### ${models[key].name}\n`;
                    report += `- **Duration:** ${result.duration}ms\n`;
                    report += `- **Length:** ${result.length} characters\n`;
                    report += `- **Quality Score:** ${score.total || 'N/A'}\n`;
                    report += `- **Content:** ${result.content.substring(0, 200)}...\n\n`;
                }
            });
            
            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-report-${Date.now()}.md`;
            a.click();
        }
        
        // Publish winner
        function publishWinner() {
            alert('발행 기능이 준비되었습니다!');
        }
        
        // Regenerate
        function regenerate() {
            generateAll();
        }
        
        // Compare all
        function compareAll() {
            alert('상세 비교 기능이 준비되었습니다!');
        }
        
        // Initialize on load
        window.onload = () => {
            initializeModels();
        };
    </script>
</body>
</html>